ECHO:

	eCho what u execute bro?
	cat ~/echo
Esto falla por que no gestionamos ~
En principio no nos lo pide el subject.

EXPORT OK
ENV OK
EXIT OK
DIRECTORY:
	Fallan:
	cd
	cd ~; pwd
	cd ..; cd ~; pwd

	El primer caso es por que no nos piden gestionar cd cuando no tiene argumentos
	Los otros dos son por que no gestionamos ~, pero no nos lo piden
	Todos dependen de gestionar el tema de HOME

PARSE:
	DOLLARS:
	6:
		->echo "'$'"<-
	Este falla por que nosotros intentamos expandir el $.
	Hay que solucionarlo.
	7, 8, 9:
		->echo $'\n'<- etc.
		Todos dependen de usar el caracter \ y el subject dice que no hay que hacerlo.
	18:
		->$NONEXIST<-
	Minishell trata esto como un argumento vacío que hay que usar como comando.
	Hay que arreglarlo.
	19:
		Igual que 18 pero tiene dos argumentos, más complicado de gestionar. Hay que tener esto en cuenta.
	20:
		Lo mismo que 18, y por ende 19, pero con variables que SI existen pero no tienen contenido
		Creo que si arreglamos 18 y 19 esto se arregla también.

	27:
		Este es más complicado. No sé decir de dónde sale el problema.
		Si hacemos
		export A='foo   ' B='bar   ' C='baz   '
			(los valores se guardan correctamente, no es cosa de export)
		Pero si hacemos:
		echo $A'$B'$C'A'
		A partir de la expansión de $C no hace nada más

		Pero si añadimos un espacio, lo siguiente sí funciona. Entonces, sospecho que
		O es un problema de ECHO o es un problema del RETOKENIZER y las COMILLAS.

		Pruebo a ver si es ECHO:
		Tiene pinta que no es ECHO, he printeado sus argumentos enteros y no hay problema en ningun lado.

		CREO QUE LO HE ARREGLADO
		Habrá que comentarlo con Chus para que quede bien integrado por que he tenido
		que cambiar alguna cosa suya

NOTA ANTES DE IRME A CASA:
Hay que pensar bien cómo solucionar que los comandos con texto vacío se traten como un comando
Por que "$VARVACIA" o "$VARQUENOEXISTE" si que cuentan como comando "", pero si no usamos las
comillas y usamos esas mismas variables entonces no cuentan como comando.
Hay que averiguar como distinguir estos casos, quizá otros.

Hay que tener en cuenta que:
$VARQUENOEXISTE $VARQUENOEXISTE
son dos tokens y aun así nos daria el error por "" command not found

Otras cosas:
Los comados antes de buscar un archivo infile que no existe, por poner un ejemplo,
no deben ejecutarse. Esto nos falla también.
Esto creo que a la vez hace que el exit status salga mal por que se conserva el del echo que si
funciona después.

Este caso:
$NOEXISTE | wc -l
Hay que hablar de esto con Chus por que tiene que ver con las pipes.
En bash, al menos en mi casa:

<comando sin contenido> | wc -l
Hace que se ejecute wc -l y reciba nada. Con lo que su output es 0.

Nuestro minishell, no ejecuta el primer comando y luego el wc -l se 
queda tal y como está, con STDIN como IN.
Bash lo hace de tal forma que wc -l no reciba STDIN como IN sino que
se corta su ejecución, y da su output 0.
Habrá que ver cómo gestiona esto bash en 42.

-- Leak en echo test 18??
En 42 lo miro a ver si ocurre
