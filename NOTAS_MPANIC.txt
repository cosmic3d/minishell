TESTS MPANIC, SUS RESULTADOS Y QUÉ SIGNIFICAN:

ECHO:
FULL OK!!!

EXPORT:
FULL OK!!

ENV:
FULL OK!!

EXIT:
!! Estoy testeando en Debian, el return status de mi bash no es el mismo que el de
los Macs de 42, así que este test no es tan fiel.
Pero en casa al menos he conseguido
FULL OK

DIRECTORY:

Test 2 KO
	"cd"
	Pero nosotros no hemos implementado "cd" sin nada por que el subject no lo
	pide explicitamente.
	No sería muy difícil de implementar si lo quisieramos.

Test 5 KO
	cd "" ""
	En mi casa, cd retorna 1 por "too many arguments", habría que ver en 42.
	No es difícil de implementar.

Test 6 KO
	"cd / non_existent"
	Igual que el test 5. Habrá que testear en 42 esto:
		cd path_valido path_invalido
	Hace el primer cd correctamente y luego da error de too many arguments?
	O simplemente da error too many arguments?

Test 15 KO
	"cd file/non_existent"
	Debería dar:
		cd: file/non_existent: Not a directory
	Da:
		cd: file/non_existent: No such file or directory

Test 18 KO
	"cd ~
	pwd"
	No hemos implementado el caracter especial '~' por que el subject no lo
	pide.

Test 19 KO
	"cd ..
	cd ~
	pwd"
	Lo mismo

Test 23 KO:
	cd "256char256char256char...." (mide 256 chars)
	Debería dar:
		cd: <nombre>: File name too long
	Da:
		cd: No such file or directory

TESTEAR TODOS ESTOS EN 42!! Recordatorio otra vez.

PARSER:
	DOLLARS:

Test 06 KO
	echo "'$'"
	Debería dar:
		'$'
	Da:
		$
Este es un problema gordo. !!!!!!!!!!!!!!!!!!!!!!!!!!

Test 07 KO
	echo $'\n' | cat -e
	Debería dar:
		$
		$
	Da:
		$\n$
Este es raro, creo que sé cómo arreglarlo:
Hay que indagar en cómo decido qué se debe considerar como algo a expandir y
qué no.
Normalmente no expandiría \n por que no puede haber una variable con ese nombre,
aunque técnicamente es posible de formas rebuscadas.
Lo que no sé es qué diferencia habría entre '\n' y solo \n.
Supongo que haría que un nombre.
Habrá qué ver cómo lo gestionan los macs de 42.
Pero, parece que bash EN CASA, hace esto:
echo $\algo
El \ se aplica a la a, por lo que se anulan, por lo tanto printea:
$algo
A nosotros nos piden explicitamente que NO gestionemos el caracter especial \.
Por lo tanto, para minishell tanto
'\n' como \n debería ser lo mismo.
Lo que me preocupa es si se espera que interpretemos \n como un salto de línea.
ESTO ES IMPORTANTE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1

Test 08 KO
	echo $'\r' | cat -e
	Lo mismo que con \n. Se espera que interpretemos \r?

Test 09 KO
	echo $'\t' | cat -e
	Lo mismo que con \n. Se espera que interpretemos \t?

Test 15 KO
	echo '$USER",$PATH,$PWD'
	NO SE NOS PRINTEA LA COMILLA DOBLE INTERIOR!!!!!!!!
	ESTO ES IMPORTANTISIMO

Test 18 KO
	$NONEXIST
	ESTO NO DEBERÍA MOSTRAR NADA!!
	EL NUESTRO DICE
	minishell: : command not found
	PROBLEMON

Test 19 KO
	$NONEXIST $NONEXIST
	Igual que test 18

Test 20 KO
	export TMPENVVAR
	$TMPENVVAR

	Igual que test 18 y 19.

Test 27 KO
	echo $A'$B'$C'A'$B'$C'
	EXPECTED:
	foo $Bbaz Abar $c
	GOT:
	foo $Bbaz
MARRONAZO!!!!!!!!!!!!!!!!!!!!!!!!

Test 29 KO
	echo $A'$B'$C'A'$B'$C'
	EXPECTED:
	foo $Bbaz Abar $C
	GOT:
	foo $Bbaz
IGUAL

Test 30 KO
	echo $A
	EXPECTED
	>foo<
	GOT
	>foo <
??????????????????????????? MARRONAZO

	QUOTES:

Test 36 KO
	echo "'$'"
	EXPECTED
	'$'
	GOT
	$
MIERDA

Test 37 KO
	echo '"$"'
	EXPECTED:
	"$"
	GOT:
	$
No lo entiendo, todo esto en su momento lo gestionabamos perfectamente.
PERFECTAMENTE. Habrá que hacer un deep deep dive en la gestión de las comillas y
el expansor.

Test 54 KO
	echo '""""""""""""'
	EXPECTED:
	>""""""""""""<
	GOT:
	><

Test 55 KO
	'echo' "hi"'' " ' "' "' "" ''''''""
	No hace falta que entre en detalles, las comillas que se deben mostrar no
	se muestran.

Test 56 KO
	echo hi"hi" hi'h"i'
	Lo mismo

Test 78 KO
	echo $" t hi t "
	EXPECTED:
	-> t hi t <-
	GOT:
	->$ t hi t <-

Test 79 KO
	echo $' t hi t '
	EXPECTED:
	-> t hi t $<-
	GOT:
	->$ t hi t $<-

Test 80 KO
	->echo $' r hi t '<-
	EXPECTED:
	-> r hi t $<-
	GOT:
	->$ r hi t $<-

	SPACES:
FULL OK!!!

	TILDE:
Hay muchos KO, por que no gestionamos el caracter ~

	SYNTAX ERROR:

Test 106 KO
	->|test<-
	EXPECTED:
		syntax error near unexpected token `|'
	GOT:
		SEGFAULT!!!!

Test 107 KO
	Igual que 106

Test 108, 109, 110, 111, 112, 113, 114, 115
	En todos estos parece que la gestión del error está bien, pero
	nos da un exit_status = 0
	En mi casa, sale que debe dar exit_status = 2
	En 42, veremos.

Test 116
	| test
	GOT: SEGFAULT

Test 117, 118, 119
	Gestión del mensaje de error bien, exit_status 0, me pide 2.
	En 42?

Test 124
	->echo hi | | echo hi<-
	GOT: SEGFAULT !!!!!
Test 125
	->echo hi ||| echo hi<-
	GOT: SEGFAULT !!!!!

Test 126 - 130
	Mensaje de error OK, exit_status = 0, me pide 2.
	En 42?

Test 131
	->echo hi >< file<-
	GOT: SEGFAULT

PARSER SECTION OVER

PIPE:
	FULL OK!!!

REDIRECTION:
	MEDIO OK, medio KO

STATUS:

Test 04
	->cat < noexiste
	echo $?<-
Fallo bien raro

Test 05
	Mensaje error OK, exit_status KO

Test 06
	echo hola > noperm
	echo $?

	Parece que el echo hola se ejecuta a pesar de que la redirección falla.
	exit_status sale mal por que pilla el bueno del echo y no el malo de la
	redirección.

Test 07, 08 y 09
	Lo mismo.

SHLVL:
	Esto en 42 será distinto por que el mensaje de warning no funciona
	exactamente igual.

Test 09
	echo $SLVL 'export SHLVL='' before ./minishell'

	El error no es por SHLVL, es por la expansión de $SLVL.
	Esto se arreglará cuando arregle eso.

NOTAS:
Cosas importantisimas a revisar:

- El funcionamiento de $
Parece que $"VAR" es viable, no me había planteado eso en ningún momento.
Y tiene todo tipo de comportamientos raros.










